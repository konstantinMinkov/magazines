package com.kpi.magazines.dao.orm.utils;

import com.kpi.magazines.dao.orm.annotations.Autogenerated;
import com.kpi.magazines.dao.orm.annotations.Column;
import com.kpi.magazines.dao.orm.annotations.Entity;
import com.kpi.magazines.dao.orm.annotations.Id;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

/**
 * Created by Konstantin Minkov on 23.06.2016.
 */
public class EntityMetadata {

    private String table;
    private List<FieldMetadata> fieldsMetadata;
    private List<String> columns;
    private FieldMetadata idFieldMetadata;

    public static class FieldMetadata {

        private String column;
        private String field;
        private boolean isAutogenerated;

        private FieldMetadata() { }

        public String getColumn() {
            return column;
        }

        public void setColumn(String column) {
            this.column = column;
        }

        public String getField() {
            return field;
        }

        public void setField(String field) {
            this.field = field;
        }

        public boolean isAutogenerated() {
            return isAutogenerated;
        }

        public void setAutogenerated(boolean autogenerated) {
            isAutogenerated = autogenerated;
        }

        @Override
        public String toString() {
            return "FieldMetadata{" +
                    "column='" + column + '\'' +
                    ", field='" + field + '\'' +
                    ", isAutogenerated=" + isAutogenerated +
                    '}';
        }
    }

    public void parseEntity(Class tClass) {
        final Field[] fields;
        final Entity entityAnnotation = (Entity) tClass.getAnnotation(Entity.class);
        FieldMetadata temp;
        if (entityAnnotation == null) {
            throw new IllegalArgumentException("Not an entity!");
        }
        table = entityAnnotation.table();
        fieldsMetadata = new ArrayList<>();
        fields = tClass.getDeclaredFields();
        for (final Field field : fields) {
            temp = parseField(field);
            if (temp != null) {
                fieldsMetadata.add(temp);
            }
        }
        //fieldsMetadata.forEach(System.out::println);
    }

    public String getTable() {
        return table;
    }

    public List<String> getColumns() {
        if (columns == null) {
            columns = new ArrayList<>(fieldsMetadata.size());
            forEachField(fieldMetadata -> columns.add(fieldMetadata.getColumn()));
        }
        return columns;
    }

    public FieldMetadata getIdFieldMetadata() {
        return idFieldMetadata;
    }

    public void forEachField(Consumer<FieldMetadata> consumer) {
        fieldsMetadata.forEach(consumer);
    }

    private FieldMetadata parseField(Field field) {
        final FieldMetadata fieldMetadata;
        final Column columnAnnotation = field.getAnnotation(Column.class);
        if (columnAnnotation == null) {
            return null;
        }
        fieldMetadata = new FieldMetadata();
        fieldMetadata.setColumn(columnAnnotation.value());
        fieldMetadata.setField(field.getName());
        if (field.getAnnotation(Autogenerated.class) != null) {
            fieldMetadata.setAutogenerated(true);
        }
        if (field.getAnnotation(Id.class) != null) {
            idFieldMetadata = fieldMetadata;
        }
        return fieldMetadata;
    }
}
